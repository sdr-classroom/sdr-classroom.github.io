<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Labo 1 - Architecture Logicielle de la solution</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/labos/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <main>
<header id="title-block-header">
    <nav>
        <a href="/labos/1-request-reply.html"><i class="fa fa-angle-left"></i> Back</a>
      </nav>
<h1 class="title">Labo 1 - Architecture Logicielle de la solution</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#exigences" id="toc-exigences">Exigences</a></li>
<li><a href="#architecture-générale"
id="toc-architecture-générale">Architecture générale</a></li>
<li><a href="#rr" id="toc-rr">RR</a>
<ul>
<li><a href="#abstraction" id="toc-abstraction">Abstraction</a></li>
<li><a href="#protocole-de-communication"
id="toc-protocole-de-communication">Protocole de communication</a></li>
<li><a href="#mise-en-oeuvre" id="toc-mise-en-oeuvre">Mise en
oeuvre</a></li>
<li><a href="#schéma" id="toc-schéma">Schéma</a></li>
</ul></li>
<li><a href="#tcp" id="toc-tcp">TCP</a>
<ul>
<li><a href="#protocole-de-connexion"
id="toc-protocole-de-connexion">Protocole de connexion</a></li>
<li><a href="#labstraction" id="toc-labstraction">L’abstraction</a></li>
<li><a href="#la-mise-en-oeuvre" id="toc-la-mise-en-oeuvre">La mise en
oeuvre</a></li>
<li><a href="#la-couche-tcp" id="toc-la-couche-tcp">La couche
TCP</a></li>
</ul></li>
</ul>
</nav>
<h2 id="exigences">Exigences</h2>
<p>Nous rappelons que le but de ce labo est d’offrir les garanties
suivantes :</p>
<ol type="1">
<li>Entre tous deux serveurs sans panne, aucun message ne doit être
perdu, dupliqué, ou réordonné.</li>
<li>Un accusé de réception doit être reçu exactement une fois pour
chaque voisin correct au sens de pannes récupérables.</li>
</ol>
<p>Nous choisissons d’implémenter un <code>NetworkInterface</code>
utilisant TCP pour offrir les garanties entre serveurs corrects (1), et
implémentant, par dessus, le protocole RR pour garantir les accusés de
réception (2). Nous décrivons ici l’architecture proposée pour mettre en
oeuvre cette solution. La solution elle-même est fournie comme point de
départ au labo 2.</p>
<h2 id="architecture-générale">Architecture générale</h2>
<p>L’architecture choisie se divise en deux modules principaux.</p>
<ul>
<li>Un module <code>RR</code> qui implémente le protocole de
communication RR sur un réseau donné abstrait.</li>
<li>Un module <code>TCP</code> qui implémente un
<code>NetworkInterface</code> utilisant des connexions RR vivant sur le
protocole TCP.</li>
</ul>
<p>Le module <code>RR</code> est intégralement indépendant de
<code>RR</code>, et <code>TCP</code> n’utilise que l’interface publique
de <code>RR</code>. Ces modules sont décrits ci-dessous.</p>
<h2 id="rr">RR</h2>
<h3 id="abstraction">Abstraction</h3>
<p>L’abstraction à laquelle correspond <code>RR</code> satisfait les
propositions suivantes :</p>
<ul>
<li>Une instance de <code>RR</code> prend en charge la communication
avec <em>exactement un</em> voisin. Il est donc attendu d’en avoir une
par voisin connu.</li>
<li>Elle permet l’envoi de messages appelés “requêtes” sous forme de
<code>[]byte</code>, auxquelles la réponse du destinataire peut être
obtenue de manière bloquante.</li>
<li>Une fonction peut être fournie à l’instance de <code>RR</code>, qui
sera appelée à chaque requête reçue, et devra retourner une réponse sous
forme de <code>[]byte</code>.</li>
<li>À sa création, une instance de <code>RR</code> nécessite un
<code>RRNetWrapper</code> représentant la communication avec un réseau
arbitraire, sous forme de channels. Ceci généralise <code>RR</code> et
facilite l’écriture de ses tests.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> RR <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sends a request to the remote address associated with this RR instance.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returns a channel on which the response will be sent.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    SendRequest<span class="op">(</span>payload <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="op">(</span>response <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sets the handler for incoming requests. The handler should return the</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// response that should be replied to the sender.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    SetRequestHandler<span class="op">(</span>handleRequest <span class="kw">func</span><span class="op">([]</span><span class="dt">byte</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Destroys the RR instance, cleaning up resources.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Close<span class="op">()</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> RRNetWrapper <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    Outgoing <span class="kw">chan</span><span class="op">&lt;-</span> <span class="op">[]</span><span class="dt">byte</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    Incoming <span class="op">&lt;-</span><span class="kw">chan</span> <span class="op">[]</span><span class="dt">byte</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> NewRR<span class="op">(</span>logger <span class="op">*</span>logging<span class="op">.</span>Logger<span class="op">,</span> remoteAddr transport<span class="op">.</span>Address<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>           network RRNetWrapper<span class="op">)</span> RR <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span></code></pre></div>
<h3 id="protocole-de-communication">Protocole de communication</h3>
<p>Les messages utilisés par la couche RR sont une simple struct
contenant le type de message (request ou reply), un sequence number et
le payload.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="op">(</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    reqMsg msgType <span class="op">=</span> <span class="ot">iota</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    rspMsg</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> message <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    Type    msgType</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    Seqnum  seqnum</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    Payload <span class="op">[]</span><span class="dt">byte</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Le sequence number est une composition d’un identifiant unique de
cette instance de RR, et d’un identifiant unique de la requête parmi
toutes celles envoyées par cette instance de RR.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> seqnum <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    InstId <span class="dt">uint64</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    MsgId  <span class="dt">uint32</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Ceci permet une unicité globale de l’identifiant du message, à
travers les instances de RR.</p>
<h3 id="mise-en-oeuvre">Mise en oeuvre</h3>
<p><code>RR</code> se divise en trois goroutines.</p>
<ul>
<li>Une goroutine d’envoi <code>handleSendRequests</code>, responsable
du protocole RR coté envoyeur. Elle maintient donc l’id du prochain
envoi, et réagit aux événements suivants.
<ul>
<li>Demandes d’envoi, reçues sur la channel
<code>sendRequests chan struct{[]byte, chan []byte}</code>, où la
<code>chan []byte</code> correspond à la channel sur laquelle devra être
envoyée la réponse du destinataire, une fois reçue. Tout envoi demandé
est transmis sur le réseau à travers l’attribut <code>Outgoing</code> du
<code>RRNetWrapper</code>.</li>
<li>Réception de messages depuis le réseau, reçus sur le channel
<code>receivedResponses chan *message</code>, qui sont utilisées pour
faire progresser le protocole RR.</li>
</ul></li>
<li>Une goroutine de gestion des requêtes reçues du réseau,
<code>handleReceivedRequests</code>. Les messages reçus sont obtenus sur
la channel <code>receivedRequests chan *message</code>. Est alors appelé
le request-handler fourni à la création du <code>RR</code>, dont la
réponse est envoyée sur le réseau via <code>Outgoing</code> de
<code>RRNetWrapper</code>.</li>
<li>Une goroutine de répartition des messages reçus par le réseau à
travers la channel <code>Incoming</code> du <code>RRNetWrapper</code>.
Elle envoie les messages de type réponse à
<code>handleSendRequests</code> et ceux de type requête à
<code>handleReceivedRequests</code>, via des channels dédiés partagés
via la struct implémentant <code>RR</code>.</li>
</ul>
<p>Nous omettons également la clôture qui suit l’approche suivante :</p>
<ul>
<li>La méthode <code>Close()</code> ferme une channel
<code>closeChan</code> ainsi que les channels écrites par des méthodes
publiques.</li>
<li>La clôture de la channel <code>closeChan</code> est détectée par
toute goroutine indépendante des méthodes publiques (ici, le dispatcher
uniquement).</li>
<li>Cette goroutine clôture à son tour toute goroutine qu’elle écrit
pour communiquer avec d’autres goroutines, leur signalant par là
qu’elles doivent également terminer (ici,
<code>handleSendRequests</code> et <code>handleReceivedRequests</code> à
travers les channels utilisés pour leur envoyer les requêtes et
réponses).</li>
</ul>
<p>Cette approche est généralement suffisante et efficace dans les cas
où il n’existe qu’un envoyeur pour chaque channel.</p>
<h3 id="schéma">Schéma</h3>
<p>Toute l’architecture de la couche <code>RR</code> est résumée dans le
schéma ci-dessous.</p>
<p><img src="/labos/imgs/1-RR.png"/></p>
<h2 id="tcp">TCP</h2>
<p>La couche TCP sert presque exclusivement de wrapper autour d’un autre
objet que nous appelons un “Gestionnaire de voisins”, ou “Remotes
Handler”. Ce dernier est motivé par le protocole de mise en place de
connexion entre voisins que nous avons choisis. Nous commençons donc par
décrire ce protocole.</p>
<h3 id="protocole-de-connexion">Protocole de connexion</h3>
<p>Nous souhaitons satisfaire les deux contraintes techniques suivantes
que nous nous imposons dans un but d’optimisation et d’élégance. Il
aurait bien sûr existé des manières moins strictes et plus simples
d’implémenter ceci.</p>
<ul>
<li>Entre tous deux voisins, une seule connexion TCP doit exister.</li>
<li>Les connexions aux voisins sont créées de manière lazy au moment de
l’envoi, afin que l’utilisateur n’ait pas besoin de gérer les
connexions.</li>
</ul>
<p>Afin de satisfaire la première exigence, nous imposons comme
invariant le fait qu’une connexion valide entre deux serveurs ne peut
avoir été instaurée que par un serveur dont l’adresse IP est plus petite
que celle de son correspondant. Ceci dans le but de résoudre le problème
de deux serveurs tentant de se connecter l’un à l’autre au même
moment.</p>
<p>Le protocole de connexion est donc le suivant :</p>
<ul>
<li>Lorsqu’une connexion doit être établie avec un voisin (e.g. lors
d’une demande d’envoi à un nouveau voisin), une connexion TCP avec ce
voisin est établie.</li>
<li>Un message de présentation est envoyé par l’instaurateur de la
connexion, incluant l’adresse IP sur laquelle ce dernier accepte de
nouvelles connexions TCP. Cela sert à informer le destinataire de son
identité, qu’il ne pourrait sans cela pas connaitre.</li>
<li>Si la connexion est valide (i.e. l’adresse du destinataire est
supérieure à celle de l’instaurateur de la connexion), elle peut être
utilisée par l’instaurateur immédiatement, et par le destinataire dès
réception du message de présentation.</li>
<li>Si la connexion est invalide, le destinataire clos immédiatement la
connexion et en déclenche une nouvelle. L’instaurateur, lui, attend que
la connexion soit fermée par le destinataire. Il est alors garanti
qu’une connexion à ce destinataire sera créée sous peu, par ce
dernier.</li>
</ul>
<p>De plus, dans le cas où une connexion est perdue en cours d’exécution
(par exemple si le voisin tombe en panne), cela ne doit pas être visible
par l’utilisateur de la couche de gestion des voisins. Aussi, le
protocole RR doit garantir que tout message perdu finira par arriver
lorsque la connexion sera à nouveau établie.</p>
<h3 id="labstraction">L’abstraction</h3>
<p>Le gestionnaire de voisins est responsable d’abstraire cette
complexité. Il n’offre qu’une méthode permettant l’envoi d’un message à
un voisin donné par une adresse IP. Cette méthode bloquera jusqu’à ce
que le message soit reçu et traité par le voisin. La gestion des
connexions, leur mise en place et leur maintient, ne font pas partie de
l’abstraction.</p>
<p>Le gestionnaire, lors de sa création, demande aussi une channel sur
laquelle il écrira tout message reçu, <code>receivedMessages</code>.</p>
<p>L’interface de ce gestionnaire peut être résumée en l’interface
suivante :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> RemoteHandler <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Request sending a message to the given remote. Will block until the</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// message was acknowledged to be received and treated by the remote.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    SendToRemote<span class="op">(</span>dest Address<span class="op">,</span> payload <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Closes all resources used by the remote handler</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    Close<span class="op">()</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> NewRemoteHandler<span class="op">(</span>self Address<span class="op">,</span> logger <span class="op">*</span>logging<span class="op">.</span>Logger<span class="op">,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                      receivedMessages <span class="kw">chan</span><span class="op">&lt;-</span> Message<span class="op">)</span> RemoteHandler <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span></code></pre></div>
<h3 id="la-mise-en-oeuvre">La mise en oeuvre</h3>
<h4 id="lobjet-remote">L’objet remote</h4>
<p>Un <code>remote</code> représente un voisin, avec lequel il n’existe
peut-être pas encore de connexion. Il regroupe une instance de
<code>RR</code> qui sera utilisée pour communiquer avec ce voisin, un
<code>RRNetWrapper</code> pour abstraire le moyen de communication
effectif (ici, une connexion TCP), et une channel
<code>sendRequests</code> de type <code>BufferedChan</code> (fournie
dans le package <code>utils</code>) dans laquelle seront transmis tous
les messages à envoyer à ce voisin.</p>
<h4 id="goroutines-centrales">Goroutines centrales</h4>
<p>Nous commençons par décrire la goroutine principale,
<code>handleRemotes</code>, responsable de la gestion d’une grande
partie de l’état, c’est à dire la liste des objets <code>remote</code>
connus et les connexions ouvertes. Elle répond aux événements
suivants.</p>
<ul>
<li>Demande d’envoi via la channel <code>sendRequests</code> (sur
laquelle la méthode publique <code>SendToRemote</code> écrit). Si le
voisin demandé n’est pas connu ou qu’il n’a pas de connexion associée,
une goroutine est lancée pour démarrer le protocole de connexion. Un
objet remote est alors créé (ou réutilisé si déjà existant), et l’envoi
est fait via sa channel <code>sendRequests</code>.</li>
<li>Demande de création d’un nouveau remote via la channel
<code>newRemoteRequest</code>. L’action est identique à la demande
d’envoi, à la différence que rien n’est envoyé sur la connexion.</li>
<li>Notification de l’existence d’une nouvelle connexion. La liste des
connexions est alors mise à jour, et une goroutine de gestion de cette
connexion est lancée.</li>
<li>Notification de clôture d’une connexion. La connexion en question
est retirée de la collection.</li>
</ul>
<p>La goroutine responsable de démarrer le protocole de connexion est
<code>tryConnect</code>. Elle ne fait qu’instaurer une connexion TCP au
voisin demandé et lui envoyer son adresse IP, suivant le protocole
décrit plus tôt. Si la connexion est valide, elle notifie alors la
goroutine principale d’une nouvelle connexion ; sinon elle attend que le
voisin clôture la connexion puis termine simplement (le voisin sera
chargé d’instaurer une connexion de son coté).</p>
<p>Enfin, une goroutine est responsable d’accepter de nouvelles
connexions TCP. Lorsqu’elle en reçoit une, elle attend le message de
présentation contenant l’adresse du voisin. Si la connexion est valide,
elle notifie la goroutine principale d’une nouvelle connexion ; sinon
elle la clôture immédiatement et envoie une demande de nouveau remote à
la goroutine principale (qui causera donc le lancement d’une goroutine
<code>tryConnect</code> pour instaurer une connexion dans le sens
valide).</p>
<h4 id="goroutines-par-voisin">Goroutines par voisin</h4>
<p>Nous décrivons maintenant les goroutines dont il existe une instance
par voisin connu.</p>
<ul>
<li>Une goroutine correspondant à une simple file d’attente pour les
messages destinés à être envoyés à travers l’instance de
<code>RR</code>. Elle est lancée par la goroutine principale dès la
création d’un nouveau <code>remote</code>. Elle réagit aux demandes
d’envoi sur sa channel <code>sendRequests</code>, et transfère le
message via la méthode <code>SendRequest()</code> de son instance
<code>RR</code>. Notez que ceci peut arriver avant même qu’une connexion
ne soit établie, mais ne risque pas de causer de deadlock car
<code>sendRequests</code> est une <code>BufferedChan</code>, d’où l’idée
que cette goroutine serve de “file d’attente”.</li>
<li>Une paire de goroutines responsables du <code>RRNetWrapper</code>
fourni à l’instance de <code>RR</code>. Pour rappel, il s’agit d’une
paire de channels que <code>RR</code> utilisera pour communiquer avec le
voisin indépendamment du protocole exact (ici, TCP). Bien que les
channels sont créés en même temps que le <code>remote</code>, les
goroutines ne sont lancées qu’une fois que la connexion est établie.
<ul>
<li>La première écoute les réceptions sur cette connexion et les
transmet au <code>RR</code> via <code>RRNetWrapper.Incoming</code>. Si
la connexion est clôturée par le voisin, elle notifie la goroutine
principale de la clôture d’une connexion puis termine.</li>
<li>La seconde écoute les demandes d’envoi que fait <code>RR</code> via
<code>RRNetWrapper.Outgoing</code> et les transmet sur la connexion.
C’est ici que <code>RR</code> bloquera tant que la connexion ne sera pas
établie et que cette paire de goroutines ne sera pas lancée.</li>
</ul></li>
</ul>
<h4 id="schéma-1">Schéma</h4>
<p>Toute l’architecture du gestionnaire de voisins est résumée dans le
schéma suivant.</p>
<p><img src="/labos/imgs/1-Remotes.png"/></p>
<h3 id="la-couche-tcp">La couche TCP</h3>
<p>Enfin, l’abstraction de gestionnaire de voisins est utilisée pour
implémenter l’abstraction d’une <code>NetworkInterface</code>.</p>
<p>Une unique nouvelle goroutine sert à maintenir la liste des
souscriptions à la réception de messages, et à propager aux souscrits
tout message reçu via la channel <code>receivedMessages</code>.</p>
<p>Cette partie est résumée dans le schéma suivant.</p>
<p><img src="/labos/imgs/1-tcp.png"/></p>
</main>
</body>
</html>
