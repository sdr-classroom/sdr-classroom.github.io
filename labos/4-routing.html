<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Labo 4 - Routing</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/labos/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <main>
<header id="title-block-header">
    <nav>
        <a href="/"><i class="fa fa-angle-left"></i> Back</a>
      </nav>
<h1 class="title">Labo 4 - Routing</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#informations-générales"
id="toc-informations-générales">Informations Générales</a></li>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#modifications-attendues"
id="toc-modifications-attendues">Modifications attendues</a>
<ul>
<li><a href="#pulsar" id="toc-pulsar">Pulsar</a></li>
<li><a href="#router" id="toc-router">Router</a></li>
</ul></li>
<li><a href="#intégration" id="toc-intégration">Intégration</a></li>
<li><a href="#tests" id="toc-tests">Tests</a></li>
<li><a href="#document-darchitecture-logicielle-et-contraintes"
id="toc-document-darchitecture-logicielle-et-contraintes">Document
d’architecture logicielle et Contraintes</a></li>
<li><a href="#timeline-et-indications"
id="toc-timeline-et-indications">Timeline et indications</a></li>
</ul>
</nav>
<!-- 
## Changelog

| Date  | Changement                                            |
| ----- | ----------------------------------------------------- |
-->
<h2 id="informations-générales">Informations Générales</h2>
<ul>
<li><a href="https://classroom.github.com/a/bGrCBxMI"><strong>Lien vers
votre repo</strong></a></li>
<li><strong>Groupes</strong> : à réaliser par groupes de deux,
potentiellement différents de ceux du labo précédent.</li>
<li><strong>Plagiat</strong> : nous intégrerons au processus
d’évaluation des outils de détection de plagiat (entre groupe, mais
aussi avec les rendus des années précédentes et la solution officielle).
En cas de suspicion, vous y serez confronté.e.s, et l’incident pourra
être rapporté au responsable de la filière, avec un risque d’échec
immédiat au cours.</li>
<li><strong>IA Générative</strong> : Nous ferons les suppositions
suivantes.
<ul>
<li>Vous avez des objectifs qui vous sont clairs (que nous espérons être
d’acquérir des compétences d’ingénieur.e).</li>
<li>Vous avez conscience que les compétences d’un.e ingénieur.e incluent
une capacité de compréhension, d’évaluation et de créativité technique,
qui sont aussi celles recherchées et valorisées dans l’industrie
<em>(lire : vous visez des jobs inatteignables par des vibe-coders
autodidactes)</em>.</li>
<li>Vous êtes des personnes responsables et adultes, capables d’agir
intentionnellement, dans l’intérêt de vos objectifs.</li>
</ul>
Par conséquent, nous supposerons que vous agirez de manière réfléchie,
et avec conscience des implications de vos choix. Par ailleurs et à
titre d’information, nous avons pu constater que les meilleurs outils en
date ne sont pas encore capables d’atteindre nos exigences sur ces
labos, qui sont suffisamment complexes pour contenir des subtilités qui
leur échappent encore.</li>
</ul>
<p>Notez enfin que l’objectif étant pour vous d’apprendre, vous serez
toujours légitimes et bienvenu.e.s à nous poser des questions, sur Go,
la théorie, vos idées, vos blocages. Si vous vous sentez perdu.e.s ou
coincé.e.s, c’est qu’il faut nous demander.</p>
<h2 id="introduction">Introduction</h2>
<p>Ce labo a pour objectif de permettre à l’application ChatsApp de
fonctionner sur un réseau incomplet, dans lequel chaque server ne
communique donc directement qu’avec un sous-ensemble des autres serveurs
du système.</p>
<p>Pour ce faire, deux modules doivent être implémentés : le
<code>Pulsar</code>, et le <code>Router</code>. Ils doivent ensuite être
intégrés au <code>Dispatcher</code>, afin que l’incomplétude du réseau
soit invisible aux modules utilisateurs, tels que la mutex ou le
mainteneur d’anneau.</p>
<p>Vous aurez accès, comme point de départ, à la solution du labo 3
ainsi qu’aux interfaces des abstractions à implémenter.</p>
<h2 id="modifications-attendues">Modifications attendues</h2>
<h3 id="pulsar">Pulsar</h3>
<p>Le premier module à implémenter est le Pulsar, qui offre le
comportement de sondes et échos générique tel que présenté en cours. Son
unique méthode, <code>StartPulse</code>, déclenche une sonde, puis
bloque jusqu’à réception de tous les échos, dont l’agrégation est alors
retournée.</p>
<p>Le Pulsar est notamment défini, à sa construction, par les objets
suivants.</p>
<ul>
<li>Un <code>PulseHandler</code>, qui est la fonction que le Pulsar
appelle à la réception d’une nouvelle sonde. Elle prend en arguments la
sonde reçue, son identifiant, et l’adresse du processus voisin envoyeur.
Elle retourne une nouvelle sonde, celle qui sera propagée aux autres
voisins, s’il en existe.</li>
<li>Un <code>EchoHandler</code>, qui est la fonction que le Pulsar
appelle lorsque tous les échos associés à une sonde sont reçus, afin
d’en obtenir l’agrégation à envoyer au parent de cette sonde. Elle prend
en arguments tous les échos reçus, la sonde correspondante, et son
identifiant, et retourne l’écho qui devra être envoyé au parent.</li>
<li>Un <code>NetSender</code>, qui est la channel sur laquelle le Pulsar
écrira les messages à envoyer sur le réseau, accompagnés de leur
destinataire.</li>
<li>Un <code>NetReceiver</code>, qui est la channel sur laquelle le
Pulsar lira les messages reçus lui étant destinés, accompagnés de leur
envoyeur.</li>
</ul>
<p>Notez bien que</p>
<ul>
<li>Le <code>PulseHandler</code> n’est appelé <strong>que lors de la
réception d’une sonde</strong> : il sera donc exécuté exactement une
fois sur tous les processus, feuilles comprises, excepté la racine
(source de la sonde), qui ne l’exécutera pas.</li>
<li>Le <code>EchoHandler</code> est appelé lorsque tous les échos sont
reçus, <strong>même s’il n’y en a aucun à recevoir</strong> : il est
donc appelé exactement une fois par chaque processus, racine et feuilles
comprises (ces dernières l’appelant alors avec une slice vide).</li>
</ul>
<h3 id="router">Router</h3>
<p>Le Router est le seul utilisateur du Pulsar, dans deux buts :
broadcasting et construction d’une table de routage. Il offre trois
méthodes.</p>
<ul>
<li><code>Broadcast</code> prend un message en argument et garantit son
envoi à tous les processus du système (et non seulement ses voisins
directs). Elle retourne une slice contenant tous les processus ayant
reçu le message.</li>
<li><code>Send</code> s’assure de l’envoi du message donné, au
destinataire donné. Pour ce faire, elle utilise une table de routage
construite en interne par le Router à l’aide de messages d’explorations
dont nous reparlons plus bas.</li>
<li><code>ReceivedMessageChan</code> retourne la channel sur laquelle le
routeur écrira tout message destiné à ce processus, reçu suite à un
appel approprié à <code>Broadcast</code> ou <code>Send</code> par un
autre processus.</li>
</ul>
<p>Son constructeur prend deux channels, similaires aux
<code>NetSender</code> et <code>NetReceiver</code> du Pulsar, permettant
de rendre le routeur indépendant du dispatcher.</p>
<p>La table de routage que le Router utilise est construite comme
suit :</p>
<ul>
<li>Initialement, seuls les voisins directs sont connus.</li>
<li>Si un destinataire ne se trouve pas dans la table de routage lors
d’un appel à <code>Send</code>, une sonde de type <em>exploration</em>
est lancée, permettant de construire une table de routage.</li>
<li>Si un processus participe à une sonde d’exploration (sans en être à
l’origine), alors il met à jour sa table de routage avec les données
récoltées par les échos qu’il agrège durant la phase de
contraction.</li>
<li>Pour tout message n’ayant pas pu être servi du fait d’une table de
routage incomplète, le message est envoyé à la prochaine mise à jour de
cette dernière permettant son envoi, <strong>tout en maintenant l’ordre
des demandes d’envoi</strong>, afin d’éviter de briser la garantie
d’absence de réordonnancement offerte par le réseau.</li>
</ul>
<p>Le Router utilise trois types de messages pour fonctionner :</p>
<ul>
<li><code>BroadcastRequest</code> et <code>BroadcastResponse</code> sont
les types d’une sonde et d’un écho conçus pour propager un message
destiné à tous les processus du réseau.</li>
<li><code>ExplorationRequest</code> et <code>ExplorationResponse</code>
sont les types d’une sonde et d’un écho utilisés pour construire une
table de routage.</li>
<li><code>RoutedMessage</code> est un message accompagné d’une source
<em>et d’une destination</em>. Les messages de ce type sont utilisés
pour envoyer un message à travers le réseau de Routers, sur la base des
tables de routage de chacun d’eux.</li>
</ul>
<h2 id="intégration">Intégration</h2>
<p>L’intégration du Router et du Pulsar se fait dans le Dispatcher, qui
gagne donc une nouvelle méthode, <code>Broadcast</code>. Toute demande
d’envoi par <code>Broadcast</code> ou par <code>Send</code> <strong>doit
donc passer par le Router</strong>.</p>
<p>Les modules utilisateurs du dispatcher ont déjà été modifiés pour
appeler <code>Broadcast</code> lorsque pertinent. Ils n’ont donc pas
connaissance du fait que le réseau est maintenant incomplet, et doivent
continuer de fonctionner inchangés.</p>
<h2 id="tests">Tests</h2>
<p>Des tests sont fournis pour vérifier le bon fonctionnement de votre
Pulsar et de votre Router, ainsi que leur intégration dans le reste du
programme.</p>
<p>Comme au labo 3, nous n’avons pas fourni tous les tests utilisés pour
évaluer votre rendu. Nous attendons de votre part que vous implémentiez
des tests additionnels, pour vérifier notamment les propriétés
suivantes, et possiblement d’autres (sachant que nous nous permettrons
d’exécuter des tests couvrant plus de propriétés que celles listées
ci-dessous, lors de l’évaluation) :</p>
<ul>
<li>Pour le Pulsar, le comportement correct lors d’une réception de
sonde, et la bonne agrégation des échos associés.</li>
<li>Pour le Router, le comportement correct de
<code>Broadcast</code>.</li>
</ul>
<p>Votre note dépendra en grande partie des résultats des tests (les
votres, ceux que nous n’avons pas fournis, et ceux fournis, y inclus
ceux des autres modules pour détecter toute régression). La qualité de
vos tests sera également prise en compte dans l’évaluation.</p>
<p>Tous les tests devront passer sans <em>et avec</em> le <a
href="https://go.dev/doc/articles/race_detector">data race detector</a>
de Go (<code>go test -race</code>).</p>
<h2 id="document-darchitecture-logicielle-et-contraintes">Document
d’architecture logicielle et Contraintes</h2>
<p>Les mêmes exigences que <a
href="/labos/1-request-reply.html#document-darchitecture">pour le labo
1</a> s’appliquent ici concernant le document d’architecture logicielle,
et les contraintes.</p>
<h2 id="timeline-et-indications">Timeline et indications</h2>
<p>Durant la première semaine, il est attendu que vous réfléchissiez à
l’approche que vous souhaitez adopter pour implémenter ce labo. Il vous
faudra notamment réfléchir à la manière de résoudre les problèmes
suivants.</p>
<ul>
<li>De combien de Goroutines aurez-vous besoin au minimum pour garantir
l’absence de deadlocks, et quelles seront leurs responsabilités ?</li>
<li>Comment les sondes seront-elles maintenues, sans problèmes de
concurrence ?</li>
<li>Comment garantirez-vous que la méthode <code>StartPulse</code> du
Pulsar bloquera jusqu’à la fin de la sonde correspondante ?</li>
<li>Comment garantirez-vous que les demandes d’envoi via le Router
seront traitées en parallèle de sondes en cours ?</li>
<li>Comment garantirez-vous que les demandes d’envoi nécessitant une
exploration seront mises en attente jusqu’à mise à jour de la table de
routage, sans bloquer les autres opérations du Router ?</li>
</ul>
<p>Après cette semaine, la séance de labo sera votre dernière occasion
de valider auprès de nous votre proposition de solution. Une fois ce
délai passé, il sera attendu que vous ayez une vision claire de votre
solution, dont vous pourrez aussitôt commencer l’implémentation.</p>
<p>Le rendu aura lieu à la fin de la dernière séance de labo du
semestre. Vous aurez donc quatre semaines (vacances exclues).</p>
</main>
</body>
</html>
