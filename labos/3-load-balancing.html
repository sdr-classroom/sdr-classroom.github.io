<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Labo 3 - Load balancing</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/labos/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <main>
<header id="title-block-header">
    <nav>
        <a href="/"><i class="fa fa-angle-left"></i> Back</a>
      </nav>
<h1 class="title">Labo 3 - Load balancing</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#informations-générales"
id="toc-informations-générales">Informations Générales</a></li>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#état-actuel" id="toc-état-actuel">État actuel</a></li>
<li><a href="#modifications-attendues"
id="toc-modifications-attendues">Modifications attendues</a></li>
<li><a href="#tests" id="toc-tests">Tests</a></li>
<li><a href="#document-darchitecture-logicielle-et-contraintes"
id="toc-document-darchitecture-logicielle-et-contraintes">Document
d’architecture logicielle et Contraintes</a></li>
<li><a href="#timeline-et-indications"
id="toc-timeline-et-indications">Timeline et indications</a></li>
</ul>
</nav>
<!-- 
## Changelog

| Date  | Changement                                            |
| ----- | ----------------------------------------------------- |
-->
<h2 id="informations-générales">Informations Générales</h2>
<ul>
<li><a href="#TODO"><strong>Lien vers votre repo</strong></a></li>
<li><strong>Groupes</strong> : à réaliser par groupes de deux,
potentiellement différents de ceux du labo précédent.</li>
<li><strong>Plagiat</strong> : nous intégrerons au processus
d’évaluation des outils de détection de plagiat (entre groupe, mais
aussi avec les rendus des années précédentes et la solution officielle).
En cas de suspicion, vous y serez confronté.e.s, et l’incident pourra
être rapporté au responsable de la filière, avec un risque d’échec
immédiat au cours.</li>
<li><strong>IA Générative</strong> : Nous ferons les suppositions
suivantes.
<ul>
<li>Vous avez des objectifs qui vous sont clairs (que nous espérons être
d’acquérir des compétences d’ingénieur.e).</li>
<li>Vous avez conscience que les compétences d’un.e ingénieur.e incluent
une capacité de compréhension, d’évaluation et de créativité technique,
qui sont aussi celles recherchées et valorisées dans l’industrie
<em>(lire : vous visez des jobs inatteignables par des vibe-coders
autodidactes)</em>.</li>
<li>Vous êtes des personnes responsables et adultes, capables d’agir
intentionnellement, dans l’intérêt de vos objectifs.</li>
</ul>
Par conséquent, nous supposerons que vous agirez de manière réfléchie,
et avec conscience des implications de vos choix. Par ailleurs et à
titre d’information, nous avons pu constater que les meilleurs outils en
date ne sont pas encore capables d’atteindre nos exigences sur ces
labos, qui sont suffisamment complexes pour contenir des subtilités qui
leur échappent encore.</li>
</ul>
<p>Notez enfin que l’objectif étant pour vous d’apprendre, vous serez
toujours légitimes et bienvenu.e.s à nous poser des questions, sur Go,
la théorie, vos idées, vos blocages. Si vous vous sentez perdu.e.s ou
coincé.e.s, c’est qu’il faut nous demander.</p>
<h2 id="introduction">Introduction</h2>
<p>Ce labo a pour objectif de compléter l’application ChatsApp pour
permettre à des clients de s’y connecter sans surcharger un serveur en
particulier.</p>
<p>Vous aurez accès, comme point de départ, à la solution au labo 2
ainsi qu’à un client et aux interfaces des abstractions à
implémenter.</p>
<h2 id="état-actuel">État actuel</h2>
<p>Dans le code de départ de ce labo, l’utilisateur.ice ne communique
plus directement avec l’exécutable du serveur, mais à travers un client.
Les modifications que nous vous fournissons par rapport au labo 2 sont
les suivantes :</p>
<ul>
<li>Un package <code>/internal/client</code> implémente un client qui se
connecte à un serveur donné, écoute la ligne de commande, envoie les
entrées de l’utilisateur au serveur, et affiche les messages reçus de la
part du serveur. Il est utilisé par le package exécutable
<code>cmd/client</code>, qui prend en arguments le nom d’utilisateur,
l’adresse du client, et l’adresse du serveur auquel se connecter.</li>
<li>Le serveur, au lieu d’échanger avec la ligne de commande, utilise
maintenant un <code>clientsManager</code>, responsable de
<ul>
<li>écouter et répondre aux demandes de connexion des clients,</li>
<li>transmettre les messages reçus de la part des clients connectés au
serveur,</li>
<li>transmettre les messages reçus par le serveur aux clients
connectés.</li>
</ul></li>
</ul>
<p>Afin de gérer la connexion des clients, le protocole de communication
client-serveur suivant est mis en place :</p>
<ul>
<li>À son lancement, le client envoie un <code>ConnRequestMessage</code>
au serveur dont l’adresse lui a été fournie en argument.</li>
<li>Le serveur répond au client par un <code>ConnResponseMessage</code>,
contenant l’adresse du serveur auquel le client a été assigné. S’il
s’agit de ce serveur, alors le client peut commencer à envoyer des
messages.</li>
<li>Le client envoie ensuite des <code>ChatMessage</code> au
serveur.</li>
<li>Lorsque le client se déconnecte, il envoie un <code>ConnClose</code>
au serveur.</li>
</ul>
<p><em><strong>Notez que, pour des raisons de simplicité, un seul client
par nom d’utilisateur n’est autorisé à se connecter au système à la
fois. Si plusieurs clients se connectent au nom du même utilisateur, le
comportement n’est pas défini.</strong></em></p>
<h2 id="modifications-attendues">Modifications attendues</h2>
<p>Actuellement, le serveur répond à tout
<code>ConnRequestMessage</code> par un <code>ConnResponseMessage</code>
contenant sa propre adresse. En d’autres termes, il accepte toute
demande de connexion, sans condition.</p>
<p>Le but de ce labo est d’implémenter un algorithme d’élection utilisé
par les serveurs pour élire celui ayant le moins de clients connectés.
Lorsqu’un client envoie un <code>ConnRequestMessage</code>, le serveur
doit répondre par un <code>ConnResponseMessage</code> contenant
l’adresse de cet élu.</p>
<p>Pour ce faire, vous devrez implémenter :</p>
<ul>
<li>Un mainteneur d’anneau dont l’interface est fournie dans
<code>election/ring/maintainer.go</code>. Cette abstraction est définie
par
<ul>
<li>la méthode <code>SendToNext(msg dispatcher.Message)</code>, qui
envoie un message au prochain processus valide dans l’anneau de manière
non bloquante,</li>
<li>la méthode <code>ReceiveFromPrev() dispatcher.Message</code>, qui
bloque jusqu’à la réception d’un message du processus valide précédent
dans l’anneau,</li>
<li>le constructeur prenant en arguments, notamment, le dispatcher,
l’adresse <code>self</code>, et une liste d’adresses <code>ring</code>,
qui doit contenir <code>self</code> et être dans l’ordre de
l’anneau.</li>
</ul></li>
<li>L’algorithme d’élection de Chang et Roberts, dont l’interface est
fournie dans <code>election/crElector.go</code>. Cette abstraction est
définie par
<ul>
<li>la méthode <code>GetLeader() transport.Address</code>, qui bloque si
une élection est en cours, puis retourne l’adresse de l’élu,</li>
<li>la méthode <code>UpdateAbility(ability int)</code>, qui met à jour
l’aptitude du processus et déclenche une nouvelle élection,</li>
<li>le constructeur prenant en arguments, notamment, le dispatcher,
l’adresse <code>self</code>, et une liste d’adresses <code>ring</code>
définie comme pour le mainteneur d’anneau.</li>
</ul></li>
</ul>
<p>Le <code>crElector</code> créera donc et utilisera un mainteneur
d’anneau pour implémenter l’algorithme d’élection de Chang et Roberts.
Il devra déclencher une nouvelle élection à chaque changement
d’aptitude, <em>et non au moment d’un appel à
<code>GetLeader</code></em> (sauf si aucun leader n’a encore été
déterminé). L’électeur sera ensuite utilisé par le
<code>clientsManager</code> pour répondre correctement aux demandes de
connexion des clients.</p>
<h2 id="tests">Tests</h2>
<p>Des tests sont fournis pour vérifier le bon fonctionnement de votre
<code>maintainer</code>, <code>crElector</code>, et
<code>clientsManager</code>.</p>
<p>Comme au labo 2, nous n’avons pas fourni tous les tests utilisés pour
évaluer votre rendu. Nous attendons de votre part que vous implémentiez
des tests additionnels, pour vérifier notamment les propriétés
suivantes, et possiblement d’autres (sachant que nous nous permettrons
d’exécuter des tests couvrant plus de propriétés que celles listées
ci-dessous, lors de l’évaluation) :</p>
<ul>
<li>Pour le mainteneur d’anneau,
<ul>
<li>Lorsqu’un envoi ne reçoit pas de réponse avant le timeout, le
prochain processus dans l’anneau est essayé.</li>
<li>À chaque nouvelle demande d’envoi de message via
<code>SendToNext</code>, le prochain processus dans l’anneau est à
nouveau essayé, même s’il n’avait pas répondu pour un message
précédent.</li>
</ul></li>
<li>Pour l’électeur,
<ul>
<li>Le comportement respecte l’algorithme de Chang et Roberts lorsque le
résultat d’une élection est reçu.</li>
<li>Lorsque l’aptitude est mise à jour <em>durant une élection</em>, une
nouvelle élection est déclenchée après la fin de la première.</li>
</ul></li>
</ul>
<p>Votre note dépendra en grande partie des résultats des tests (les
votres, ceux que nous n’avons pas fournis, et ceux fournis, y inclus
ceux des autres modules pour détecter toute régression). La qualité de
vos tests sera également prise en compte dans l’évaluation.</p>
<p>Tous les tests devront passer sans <em>et avec</em> le <a
href="https://go.dev/doc/articles/race_detector">data race detector</a>
de Go (<code>go test -race</code>).</p>
<h2 id="document-darchitecture-logicielle-et-contraintes">Document
d’architecture logicielle et Contraintes</h2>
<p>Les mêmes exigences que <a
href="/labos/1-request-reply.html#document-darchitecture">pour le labo
1</a> s’appliquent ici concernant le document d’architecture logicielle,
et les contraintes.</p>
<h2 id="timeline-et-indications">Timeline et indications</h2>
<p>Durant la première semaine, il est attendu que vous réfléchissiez à
l’approche que vous souhaitez adopter pour implémenter ce labo. Il vous
faudra notamment réfléchir à la manière de résoudre les problèmes
suivants.</p>
<ul>
<li>De combien de Goroutines aurez-vous besoin au minimum pour garantir
l’absence de deadlocks, et quelles seront leurs responsabilités ?</li>
<li>Comment garantirez-vous qu’aucun état ne sera accédé concurremment
par plusieurs goroutines ?</li>
<li>Comment utiliser l’abstraction d’électeur pour permettre une
répartition de charge entre serveurs ?</li>
</ul>
<p>Après cette semaine, la séance de labo sera votre dernière occasion
de valider auprès de nous votre proposition de solution. Une fois ce
délai passé, il sera attendu que vous ayez une vision claire de votre
solution, dont vous pourrez aussitôt commencer l’implémentation.</p>
<p>Le rendu aura lieu une minute avant le début du labo 4. Vous aurez
donc quatre semaines (vacances exclues).</p>
</main>
</body>
</html>
